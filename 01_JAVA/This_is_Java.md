**개요**

[toc]

# 0. JAVA 구문

`이것이 자바다 -신용권의 Java 프로그래밍 정복` 책 참고



# 1. 변수와 타입

### 변수

하나의 값을 저장할 수 있는 메모리 공간

---

### 변수 선언

###### 변수 명명 규칙

1. 첫 번째 글자는 문자이거나 `$`나 `-` 가 올 수 있으며 숫자로 시작할 수는 없음
2. 영어 대소문자가 구분
3. 첫 문자는 영어 소문자로 시작하되, 다른 단어가 붙을 경우 첫 문자를 대문자로 하여 구분
4. 문자 수 제한 없음
5. 자바 예약어 사용 불가

###### 변수값 저장

`변수 타입` `변수명` = `초기값` 

우측의 값을 좌측 변수에 저장

---

### 데이터 타입

정수 -> byte, char, short, int, long

실수 -> float, double

논리 -> boolean

---

### 연산자

###### 연산

-프로그램에서 데이터를 처리하여 결과를 산출하는 것

###### 기능

산술연산자, 비교연산자, 논리연산자, 조건연산자, 대입연산자

`++`. `--`. `+`,  `-`, `!`, `~`, (타입명) {부호 연산자}  ←단항 연산자
`*`, `/`, `%`
`+`, `-`
`==`, `!=`, `>`, `<`, `>=`, `<=`, `instanceof`  ← 연산결과가 `boolean` 으로 나옴

비트 연산자

`>>`,  `>>>`,  `<<`,  `<<<`
`&`, `|`, `^`

논리 연산자

`&& ` or `&` - 논리곱
`||`  or `|`- 논리합

`^` - 배타적 논리합

`!` - 논리 부정

항1 ? 항2 : 항3
`=`, `+=`, `-=`, `*=`, `/=`

---



# 조건문과 반복문

## if

조건식의 결과에 따라 블록 실행 여부가 결정

```
if (조건식) {
	조건식이 true일 경우 실행
} else {
	조건식이 false일 경우 실행
}
```

## switch

```
switch (변수) {
	case 값1:
		변수가 값1일 경우
		break;
	
	case 값2:
		변수가 값2일 경우
		break;
	
	default:
		변수가 값1, 값2 모두 아닐 경우
}
```

## 반복문

### for문

```
for (¹초기화식; ²조건식; ⁴증감식) {
	³실행문; ⇦ 조건식이 true일 경우
}
```

> `ⁿ`  - 코드 실행 흐름

### while문

```
while (¹조건식) {
	²실행문; ⇦ 조건식이 true일 경우
} 
```

> 조건식이 false일 경우 종료

### do-while 문

```
do {
	¹실행문; ⇦ 최초 실행
} while (²조건식); ⤴ 조건식이 true일 경우 다시 실행문 쪽으로/false일 경우 종료 
```

### break 문

- switch, for, while, do-while 문들을 특정 상황에 바로 종료 시키고 싶을 때 사용

### continue 문

- 반복문을 종료하지 않고 계속 반복 수행 가능

---

# 참조 타입

## 데이터 타입 분류

- 기본 타입
  - 정수 타입
    - byte
    - char
    - short
    - int
    - long
  - 실수 타입
    - float
    - double
  - 논리 타입
    - boolean
- 참조 타입
  - 배열 타입
  - 열거 타입
  - 클래스
  - 인터페이스

---

## 메모리 사용 영역

### JVM Stack 영역 

- 각 스레드 마다 하나씩 존재
- 스레드가 시작될 때 할당
- 메소드를 호출할 때마다 Frame을 push
- 메소드가 종료되면 해당 프레임을 pop



### null

- 힙 영역의 객체를 참조하지 않는다

- 초기값으로 사용 가능

- 초기화된 참조 변수는 스택 영역에 생성



### String

```java
String 변수;
변수 = "문자열";
```



### 배열 타입

- 동일한 타입의 데이터들에 각각 `index`를 부여해서 연속된 공간에 나열시킨 자료구조
- 대괄호`[]` 사용

```java
배열이름[index]
```

- 배열 선언

```java
타입[] 변수;

// 중괄호에 값들을 넣어서 만들 수도 있다
타입[] 변수 = {data, data1, data2, ...};
```



### 향상된 for문

```java
for (²타입 변수 : ¹배열) {
  ³실행문;
}
```



# 클래스



### 객체

>자신의 속성을 가지고 다른 것과 식별 가능한 것
>
>속성과 기능으로 구성
>
>속성 = 필드, 기능 = 메소드
>
>ex)
>
>속성 : 크기, 길이, 높이, 색상, 등
>
>기능 : 켜기, 끄기, 전진하기, 후진하기, 등

### 객체 간 관계

집합 관계 : 전체와 부분의 관계

사용 관계 : 객체 간의 상호작용

상속 관계 : 부모 객체를 기반으로 자식 객체를 생성하는 관계



**객체 지향 프로그래밍이란 완성품인 객체를 모델링하여 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 설계, 조합하는 프로그래밍**



## 클래스 구성 요소

### 필드

객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳

생성자와 메소드 전체에서 사용

객체가 소멸되지 않는 한 계속 존재

### 생성자

객체 생성 시 초기화

인스턴스 변수의 초기화 또는 인스턴스 생성할 때 수행할 작업에 사용

메소드 호출

### 메소드

객체의 동작에 해당하는 `{}`

필드를 읽고 수정하는 역할 등 다양한 역할

객체 간 데이터 전달 수단

외부로부터 매개값을 받을 수 있고 실행 후 특정 값을 리턴 가능

이름을 정할 때 숫자로 시작해선 안되고, `$` 와 `_` 외의 특수문자 사용은 지양

관례적으로 소문자로 작성하기



# 상속 extends

자바의 모든 객체들은 객체지향언어의 특징인 `상속` 을 지원

부모 클래스의 멤버를 자식클래스에게 물려줄 수 있음 

코드를 재사용하기에 코드의 중복을 줄여줌

다중 상속 불가

## @Override

상속된 메소드의 내용이 자식 클래스에 맞지 않을 때, 자식 클래스에서 동일한 메소드를 재정의



## 접근 제한자

 제한 강함 <-----------------------> 제한 약함 

`-` private  >  `()` default  >  `#` protected  >  `+` public



객체에 대한 권한을 쉽게 얻을 수 있으면 문제가 생길 수 있다.

setter와 getter를 사용해 캡슐화를 달성하여 다른 객체에 정보를 숨기고, 오직 연산만을 통해서 접근 할 수 있도록 한다.(정보은닉 가능)



### 활용 제한자

---

final, static, abstract, transient, synchronized

사용 방법을 제한함

```java
`제한자` class ClassName extends ParentClassName {
  `제한자` 멤버변수 선언;
  `제한자` 생성자 메소드;
  `제한자` 메소드 정의
}

public/final/abstract class ClassName extends ParentClassName {
  public이 설정된 클래스 : 누구나 접근가능
  deafult 클래스 : 동일 패키지의 클래스만 
	- final : 변경할 수 없음, 마지막의
	- abstract : 반드시 변경해야함, 마지막 X, 미완성의
   => 제어자로서의 final 과 abstract은 정반대
```



### abstract

---

미완성 클래스

상속만 가능

객체 생성 불가



### Casting

---

부모 타입을 자식 타입으로 변환

자식 타입이 부모 타입으로 자동 변환한 뒤, 다시 자식 타입으로 바뀔 때 강제 타입 변환 사용

부모 타입에 선언된 필드와 메소드만 사용 가능



# 인터페이스

## 역할

호한성을 높여줌

다형성을 구현

개발 코드와 객체가 서로 통신하는 접점 역할

메소드를 호출할 시 인터페이스는 객체의 메소드를 호출

개발 코드를 수정하지 않고, 사용하는 개체를 변경할 수 있도록 해줌

코드 변경없이 실행 내용과 리턴값을 다양화 할 수 있음



## 선언

`.java` 형태의 소스 파일로 작성

`.class` 형태로 컴파일

-> 물리적 형태는 클래스와 동일 but 선언 방식이 다름

```java
제한자 interface interfaceName {
  ...
}
```

## 추상 메소드 선언

인터페이스를 통해 호추로딘 메소드는 객체에서 실행 -> 인터페이스의 메소드는 실행 블록이 필요 없음

추상메소드 = 리턴 타입, 메소드명, 매개변수만 기록, `{}` 가 없음

public abstract 특성 보유



## 구현

객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 메소드를 갖고 있어야 함

이 객체를 구현 객체라고 한다.



### 구현 클래스

보통 클래스와 동일

선언부에 `implements` 와 인터페이스 이름 명시





